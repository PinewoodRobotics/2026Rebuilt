plugins {
    id "java"
    id "edu.wpi.first.GradleRIO" version "2026.2.1"
    id "com.google.protobuf" version "0.9.3"
    id "groovy"
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

ext {
    alreadyAdded = []
}

repositories {
    mavenCentral()
    maven {
        url 'https://jitpack.io'
    }
}

def ROBOT_MAIN_CLASS = "frc.robot.Main"

def EXPECTED_NUM_OF_PIS = 3;
def dynamicLibDir = layout.projectDirectory.dir("lib/build")

// Define deploy target and artifacts
deploy {
    targets {
        roborio(getTargetTypeClass('RoboRIO')) {
            team = project.frc.getTeamNumber()
            debug = project.frc.getDebugOrDefault(false)

            artifacts {
                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {}

                frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
                    files = project.fileTree("src/main/deploy")
                    directory = '/home/lvuser/deploy'
                }
            }
        }
    }
}

def deployArtifact = deploy.targets.roborio.artifacts.frcJava

wpi.java.debugJni = false

def includeDesktopSupport = false

def buildDynamicDepsTask = tasks.register("buildDynamicDeps") {
    group = "build setup"
    description = "Clones/builds dynamic deps and drops jars into lib/build"

    inputs.file("config.ini")
    outputs.dir(dynamicLibDir)
    outputs.upToDateWhen { false }  // run every build cycle so deps are always refreshed

    doLast {
        def stdout = new ByteArrayOutputStream()
        def stderr = new ByteArrayOutputStream()

        try {
            exec {
                def javaHome =
                        System.getenv("JAVA_HOME")
                        ?: (project.findProperty("org.gradle.java.home") as String)
                        ?: System.getProperty("java.home")

                environment "JAVA_HOME", javaHome
                environment "PATH", "${javaHome}/bin:${System.getenv("PATH")}"

                commandLine "python3", "scripts/clone_and_build_repos.py",
                        "--config-file-path", "config.ini"

                standardOutput = stdout
                errorOutput = stderr
            }
        } catch (Exception e) {
            // print error output, then rethrow
            def err = stderr.toString().trim()
            if (err) println err
            println "Exception during exec: $e"
            throw e
        }

        println stdout.toString().trim()
        def err = stderr.toString().trim()
        if (err) println err
    }
}

// Create a provider that forces lazy evaluation of the directory
// This ensures VSCode picks up new JARs when it refreshes the classpath
def dynamicJarsProvider = buildDynamicDepsTask.map { 
    dynamicLibDir 
}

// Define project dependencies
dependencies {
    implementation wpi.java.deps.wpilib()
    implementation wpi.java.vendor.java()

    roborioDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.roborio)
    roborioDebug wpi.java.vendor.jniDebug(wpi.platforms.roborio)

    roborioRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.roborio)
    roborioRelease wpi.java.vendor.jniRelease(wpi.platforms.roborio)

    nativeDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.desktop)
    nativeDebug wpi.java.vendor.jniDebug(wpi.platforms.desktop)
    simulationDebug wpi.sim.enableDebug()

    nativeRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.desktop)
    nativeRelease wpi.java.vendor.jniRelease(wpi.platforms.desktop)
    simulationRelease wpi.sim.enableRelease()
    
    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'

    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    implementation "com.google.protobuf:protobuf-java:3.22.2"
    // Use provider with fileTree to force lazy evaluation so VSCode picks up new JARs
    implementation(files(dynamicJarsProvider.map { dir -> 
        fileTree(dir: dir, include: "*.jar") 
    }).builtBy(buildDynamicDepsTask))
}

test {
    useJUnitPlatform()
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
}

// Simulation settings
wpi.sim.addGui().defaultEnabled = true
wpi.sim.addDriverstation()

// Create a fat jar (including all dependencies) and set the manifest for WPILib
jar {
    from sourceSets.main.output
    from({ configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } })
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Set the jar task for deployment
deployArtifact.jarTask = jar
wpi.java.configureExecutableTasks(jar)
wpi.java.configureTestTasks(test)


protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.22.2"
    }
    generateProtoTasks {
        all().each { task ->
            task.builtins {
                java {}
            }
        }
    }

    generatedFilesBaseDir = "$buildDir/generated/source"
}

sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/source/proto/main/java"
        }
        proto {
            srcDirs = ['src/proto']
        }
    }
}

def applyBackend(expectedNumOfPis) {
  def stdout = new ByteArrayOutputStream()
  def stderr = new ByteArrayOutputStream()
  def buildFailed = false

  try {
    project.exec {
      commandLine "make", "deploy-backend"
      standardOutput = stdout
      errorOutput = stderr
      ignoreExitValue = false
    }
  } catch (Exception e) {
    buildFailed = true
    println "Failed to apply backend: ${e.message}"
    println "Error Output:\n${stderr.toString().trim()}"
  }

  println stdout;
  println stderr;

  if (!stderr.toString().contains("Deployed on " + expectedNumOfPis.toString() + " Pis") && !stdout.toString().contains("Deployed on " + expectedNumOfPis.toString() + " Pis")) {
    println ""
    println "============================================================="
    println "Failed to apply backend because it was not deployed on the expected number of Pis. Please set the expected number of Pis in the build.gradle file and try again (check 'EXPECTED_NUM_OF_PIS' variable)."
    println "Expected number of Pis: " + expectedNumOfPis.toString()
    println "Deployed number of Pis: " + stdout.toString().split("Deployed on ")[1].split(" Pis")[0]
    println "============================================================="
    println ""

    throw new Exception("Failed to apply backend because it was not deployed on the expected number of Pis (expected " + expectedNumOfPis.toString() + " Pis, deployed " + stdout.toString().split("Deployed on ")[1].split(" Pis")[0] + " Pis)")
  }
}

// buildDynamically("./config.ini")

tasks.register("applyBackend") {
    group = "build"
    description = "Apply backend"
    doLast {
        applyBackend(EXPECTED_NUM_OF_PIS)
    }
}

// tasks.deploy.dependsOn(tasks.applyBackend)

tasks.jar.dependsOn(tasks.generateProto)
tasks.compileJava.dependsOn(tasks.generateProto)
tasks.compileJava.dependsOn(tasks.buildDynamicDeps)