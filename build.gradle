plugins {
    id "java"
    id "edu.wpi.first.GradleRIO" version "2026.2.1"
    id "com.google.protobuf" version "0.9.3"
    id "groovy"
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

ext {
    alreadyAdded = []
}

repositories {
    mavenCentral()
    maven {
        url 'https://jitpack.io'
    }
}

def ROBOT_MAIN_CLASS = "frc.robot.Main"

def EXPECTED_NUM_OF_PIS = 3;

// Define deploy target and artifacts
deploy {
    targets {
        roborio(getTargetTypeClass('RoboRIO')) {
            team = project.frc.getTeamNumber()
            debug = project.frc.getDebugOrDefault(false)

            artifacts {
                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {}

                frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
                    files = project.fileTree("src/main/deploy")
                    directory = '/home/lvuser/deploy'
                }
            }
        }
    }
}

def deployArtifact = deploy.targets.roborio.artifacts.frcJava

wpi.java.debugJni = false

def includeDesktopSupport = false

// Define project dependencies
dependencies {
    implementation wpi.java.deps.wpilib()
    implementation wpi.java.vendor.java()

    roborioDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.roborio)
    roborioDebug wpi.java.vendor.jniDebug(wpi.platforms.roborio)

    roborioRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.roborio)
    roborioRelease wpi.java.vendor.jniRelease(wpi.platforms.roborio)

    nativeDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.desktop)
    nativeDebug wpi.java.vendor.jniDebug(wpi.platforms.desktop)
    simulationDebug wpi.sim.enableDebug()

    nativeRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.desktop)
    nativeRelease wpi.java.vendor.jniRelease(wpi.platforms.desktop)
    simulationRelease wpi.sim.enableRelease()
    
    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'
    implementation "com.google.protobuf:protobuf-java:3.22.2"

    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

test {
    useJUnitPlatform()
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
}

// Simulation settings
wpi.sim.addGui().defaultEnabled = true
wpi.sim.addDriverstation()

// Create a fat jar (including all dependencies) and set the manifest for WPILib
jar {
    from sourceSets.main.output  // Your classes FIRST
    from({ configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }) {
        exclude "proto/**"
    }
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Set the jar task for deployment
deployArtifact.jarTask = jar
wpi.java.configureExecutableTasks(jar)
wpi.java.configureTestTasks(test)

// Configure the string concatenation setting for inline compilation
tasks.withType(JavaCompile) {
    options.compilerArgs.add '-XDstringConcat=inline'
}

// Function to build dependencies dynamically. This calls a python script that clones and builds the dependencies.
// It then adds the jars to the classpath.
def buildDynamically(configFilePath) {
    def stdout = new ByteArrayOutputStream()
    def stderr = new ByteArrayOutputStream()
    def buildFailed = false

    try {
        project.exec {
          def javaHome =
                  System.getenv("JAVA_HOME")
                  ?: (project.findProperty("org.gradle.java.home") as String)
                  ?: System.getProperty("java.home")

          environment "JAVA_HOME", javaHome
          environment "PATH", "${javaHome}/bin:${System.getenv("PATH")}"

          commandLine "python3", "scripts/clone_and_build_repos.py", "--config-file-path", configFilePath
          standardOutput = stdout
          errorOutput = stderr
          ignoreExitValue = false
      }
    } catch (Exception e) {
        buildFailed = true
        // ANSI escape code for red: \u001B[31m, reset: \u001B[0m
        println "\n\n" +
                "\u001B[31m" +
                "#############################################################\n" +
                "#                                                           #\n" +
                "#                FAILED TO BUILD DEPENDENCIES!              #\n" +
                "#                                                           #\n" +
                "#############################################################\n" +
                "\u001B[0m"
        println "\u001B[31mExecution failed: ${e.message}\u001B[0m"
    }

    if (stdout.toString().contains("FAILED") || stderr.toString().toLowerCase().contains("error") || buildFailed) {
        println "\n\n" +
                "\u001B[31m" +
                "#############################################################\n" +
                "#                                                           #\n" +
                "#                FAILED TO BUILD DEPENDENCIES!              #\n" +
                "#                                                           #\n" +
                "#############################################################\n" +
                "\u001B[0m"
        println "\u001B[31mError Output:\n${stderr.toString().trim()}\u001B[0m"
    }

    println "Standard Output:\n${stdout.toString().trim()}"
    println "Error Output:\n${stderr.toString().trim()}"

    // ANSI escape code for green: \u001B[32m, reset: \u001B[0m
    println "\n\n" +
        "\u001B[32m" +
        "#############################################################\n" +
        "#                                                           #\n" +
        "#                BUILT DYNAMIC DEPENDENCIES!                #\n" +
        "#                                                           #\n" +
        "#############################################################\n" +
        "\u001B[0m"

    def jarFiles = fileTree(dir: "lib/build", include: '*.jar')

    project.afterEvaluate {
        dependencies {
            implementation files(jarFiles)
        }
    }
}

def applyBackend(expectedNumOfPis) {
  def stdout = new ByteArrayOutputStream()
  def stderr = new ByteArrayOutputStream()
  def buildFailed = false

  try {
    project.exec {
      commandLine "make", "deploy-backend"
      standardOutput = stdout
      errorOutput = stderr
      ignoreExitValue = false
    }
  } catch (Exception e) {
    buildFailed = true
    println "Failed to apply backend: ${e.message}"
    println "Error Output:\n${stderr.toString().trim()}"
  }

  println stdout;
  println stderr;

  if (!stderr.toString().contains("Deployed on " + expectedNumOfPis.toString() + " Pis") && !stdout.toString().contains("Deployed on " + expectedNumOfPis.toString() + " Pis")) {
    println ""
    println "============================================================="
    println "Failed to apply backend because it was not deployed on the expected number of Pis. Please set the expected number of Pis in the build.gradle file and try again (check 'EXPECTED_NUM_OF_PIS' variable)."
    println "Expected number of Pis: " + expectedNumOfPis.toString()
    println "Deployed number of Pis: " + stdout.toString().split("Deployed on ")[1].split(" Pis")[0]
    println "============================================================="
    println ""

    throw new Exception("Failed to apply backend because it was not deployed on the expected number of Pis (expected " + expectedNumOfPis.toString() + " Pis, deployed " + stdout.toString().split("Deployed on ")[1].split(" Pis")[0] + " Pis)")
  }
}

buildDynamically("./config.ini")

tasks.register("applyBackend") {
    group = "build"
    description = "Apply backend"
    doLast {
        applyBackend(EXPECTED_NUM_OF_PIS)
    }
}

tasks.register("cleanGeneratedProto") {
    group = "build"
    description = "Delete protobuf generated + extracted sources to avoid stale incremental builds"
    doLast {
        // Generated Java sources from protoc (your override uses this base dir)
        delete("$buildDir/generated/source")
        // Protos extracted from dependencies (Gradle protobuf plugin caches these)
        delete("$buildDir/extracted-protos")
        delete("$buildDir/extracted-include-protos")
    }
}

tasks.build.dependsOn(tasks.generateProto)

tasks.deploy.dependsOn(tasks.applyBackend)

tasks.jar.dependsOn(tasks.generateProto)
tasks.compileJava.dependsOn(tasks.generateProto)

tasks.withType(com.google.protobuf.gradle.GenerateProtoTask).configureEach {
    dependsOn(tasks.cleanGeneratedProto)
}


protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.22.2"
    }
    generateProtoTasks {
        all().each { task ->
            task.builtins {
                java {
                    // IMPORTANT:
                    // Do NOT generate "lite" Java protobufs here.
                    //
                    // The Autobahn client dependency expects full protobuf-generated builders
                    // where methods like `TopicMessage.Builder.build()` have the concrete return
                    // type. In lite mode, `build()` is inherited from GeneratedMessageLite and
                    // has an erased return type, which causes a runtime NoSuchMethodError.
                }
            }
        }
    }

    generatedFilesBaseDir = "$buildDir/generated/source"
}

sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/source/proto/main/java"
        }
        proto {
            srcDirs = ['src/proto']
        }
    }
}